<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>Chamada de Vídeo Permanente</title>
  <style>
    body {
      background-color: #121212;
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      margin: 0;
      font-family: Arial, sans-serif;
    }

    video {
      width: 400px;
      max-width: 90%;
      border: 4px solid #00cec9;
      border-radius: 12px;
      background: black;
    }

    button {
      margin-top: 20px;
      padding: 10px 20px;
      font-size: 16px;
      border-radius: 8px;
      background-color: #00b894;
      color: white;
      border: none;
      cursor: pointer;
      transition: 0.3s;
    }

    button:hover {
      background-color: #00a08b;
    }

    .status {
      margin-top: 10px;
      font-size: 14px;
      color: #00cec9;
    }
  </style>
</head>
<body>

  <h1>Chamada de Vídeo Permanente</h1>
  <video id="localVideo" autoplay muted></video>
  <video id="remoteVideo" autoplay></video>
  <div class="status" id="status-text">🔴 Esperando conexão...</div>

  <button onclick="toggleCamera()">Ativar/Desativar Câmera</button>
  <button onclick="toggleMicrophone()">Ativar/Desativar Microfone</button>
  <button onclick="shareScreen()">Compartilhar Tela</button>

  <script>
    let localStream;
    let remoteStream;
    let peerConnection;
    let socket;
    const serverConfig = {
      iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
    };

    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const statusText = document.getElementById('status-text');
    
    let screenStream;
    let isCameraEnabled = false; // Inicia com a câmera desativada
    let isMicrophoneEnabled = true; // Inicia com o microfone ativado

    // Conectar ao servidor WebSocket
    socket = new WebSocket('ws://localhost:8080');
    socket.onopen = () => {
      console.log('Conectado ao servidor WebSocket');
      startCall();  // Conectar automaticamente assim que a WebSocket for aberta
    };

    socket.onmessage = (event) => {
      const message = JSON.parse(event.data);
      if (message.offer) {
        acceptCall(message.offer);
      } else if (message.answer) {
        peerConnection.setRemoteDescription(new RTCSessionDescription(message.answer));
      } else if (message.iceCandidate) {
        peerConnection.addIceCandidate(new RTCIceCandidate(message.iceCandidate));
      }
    };

    // Função para capturar a mídia (câmera e microfone)
    async function getMedia() {
      try {
        // Solicita áudio (sempre ativado) e vídeo (desativado)
        const constraints = { audio: true, video: false };
        localStream = await navigator.mediaDevices.getUserMedia(constraints);
        localVideo.srcObject = localStream;
      } catch (error) {
        console.error('Erro ao acessar mídia:', error);
        alert('Erro ao acessar o microfone.');
      }
    }

    // Função para entrar automaticamente na chamada
    async function startCall() {
      await getMedia(); // Apenas o áudio será ativado
      peerConnection = new RTCPeerConnection(serverConfig);

      // Adiciona o stream de áudio à conexão
      localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

      // Cria a oferta e envia para o servidor WebSocket
      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);
      socket.send(JSON.stringify({ offer }));

      statusText.textContent = '📞 Conectando...';

      peerConnection.ontrack = (event) => {
        remoteStream = event.streams[0];
        remoteVideo.srcObject = remoteStream;
        statusText.textContent = '📹 Conexão estabelecida!';
      };

      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          socket.send(JSON.stringify({ iceCandidate: event.candidate }));
        }
      };
    }

    // Função para aceitar a chamada (usuário entrando na sala)
    async function acceptCall(offer) {
      peerConnection = new RTCPeerConnection(serverConfig);

      // Adiciona o stream de áudio à conexão
      localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

      // Define a oferta recebida
      await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));

      // Cria a resposta e envia para o servidor WebSocket
      const answer = await peerConnection.createAnswer();
      await peerConnection.setLocalDescription(answer);
      socket.send(JSON.stringify({ answer }));

      peerConnection.ontrack = (event) => {
        remoteStream = event.streams[0];
        remoteVideo.srcObject = remoteStream;
        statusText.textContent = '📹 Conexão estabelecida!';
      };

      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          socket.send(JSON.stringify({ iceCandidate: event.candidate }));
        }
      };
    }

    // Função para ativar/desativar a câmera
    function toggleCamera() {
      if (localStream.getVideoTracks().length > 0) {
        const videoTrack = localStream.getVideoTracks()[0];
        isCameraEnabled = !isCameraEnabled;
        videoTrack.enabled = isCameraEnabled;
        statusText.textContent = isCameraEnabled ? '🎥 Câmera ativada' : '🎥 Câmera desativada';
      } else {
        alert("Você ainda não iniciou a câmera!");
      }
    }

    // Função para ativar/desativar o microfone
    function toggleMicrophone() {
      const audioTrack = localStream.getAudioTracks()[0];
      isMicrophoneEnabled = !isMicrophoneEnabled;
      audioTrack.enabled = isMicrophoneEnabled;
      statusText.textContent = isMicrophoneEnabled ? '🎤 Microfone ativado' : '🎤 Microfone desativado';
    }

    // Função para compartilhar a tela
    async function shareScreen() {
      try {
        screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
        const screenTrack = screenStream.getTracks()[0];
        localStream.addTrack(screenTrack); // Adiciona o track da tela ao stream local

        // Atualiza o vídeo local com a tela compartilhada
        localVideo.srcObject = localStream;
        statusText.textContent = '📱 Compartilhando tela...';

        // Envia o track de tela para o peer
        peerConnection.addTrack(screenTrack, localStream);
      } catch (err) {
        console.error('Erro ao compartilhar a tela:', err);
        alert('Erro ao compartilhar a tela.');
      }
    }
  </script>

</body>
</html>
